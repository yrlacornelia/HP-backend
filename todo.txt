controllers


renskriva och få allt att funka

börja med user profile etc
user profile page:
logga in x
se sin info x
byta info x
tailwind byta läge efter hus
user image x
all info
logga ut knapp
lägga till logga in sida

chat:
renskriva
göra chat entity
man ska kunna chatta med varandra och man ska kunna chatta från olika rum


shop:




admin ( jag är admin tills slutet)


frågor:
why serialization


todo:
settings:
uppdatera profileimage password och username



@GetMapping("/userSettings")
    public ResponseEntity<User> userPage() {
        String username = authService.getCurrentUsername();
        User user = userRepository.findByUsername(username);
/*        String base64Image;
        if(user.getImageData() != null) {
            base64Image = Base64.getEncoder().encodeToString(user.getImageData());
        }
        else {
            try {
                Path imagePath = Path.of(resourceLoader.getResource("classpath:images/profile.jpeg").getURI());
                System.out.println(Arrays.toString(Files.readAllBytes(imagePath)));
                user.setImageData(Files.readAllBytes(imagePath));
                base64Image = Base64.getEncoder().encodeToString(user.getImageData());
            } catch (IOException e) {
                e.printStackTrace();

                return null;
            }
        }*/
    /*    Map<String, Object> response = new HashMap<>();
        response.put("user", user);
        response.put("imageData", base64Image);
*/
        return ResponseEntity.ok().body(user);
    }



    cheatcheets

    ALTER TABLE user MODIFY image_data LONGBLOB;






    USE chat_app;

    CREATE TABLE users (
        id INT AUTO_INCREMENT PRIMARY KEY,
        username VARCHAR(50) NOT NULL UNIQUE,
        password VARCHAR(255) NOT NULL,
    );

    CREATE TABLE messages (
        id INT AUTO_INCREMENT PRIMARY KEY,
        user_id INT NOT NULL,
        message TEXT NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
    );

    CREATE TABLE chat_rooms (
        id INT AUTO_INCREMENT PRIMARY KEY,
        room_name VARCHAR(50) NOT NULL UNIQUE,
    );

    CREATE TABLE room_messages (
        id INT AUTO_INCREMENT PRIMARY KEY,
        room_id INT NOT NULL,
        user_id INT NOT NULL,
        message TEXT NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (room_id) REFERENCES chat_rooms(id) ON DELETE CASCADE,
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
    );





CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    password VARCHAR(255) NOT NULL
);

CREATE TABLE messages (
    id INT AUTO_INCREMENT PRIMARY KEY,
    sender_id INT NOT NULL,
    receiver_id INT NOT NULL,
    message TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (sender_id) REFERENCES users(id) ON DELETE CASCADE,
    FOREIGN KEY (receiver_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE TABLE chat_rooms (
    id INT AUTO_INCREMENT PRIMARY KEY,
    room_name VARCHAR(50) NOT NULL UNIQUE
);

CREATE TABLE room_messages (
    id INT AUTO_INCREMENT PRIMARY KEY,
    room_id INT NOT NULL,
    user_id INT NOT NULL,
    message TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (room_id) REFERENCES chat_rooms(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);



user skickar ett meddelande




https://spring.io/guides/gs/messaging-stomp-websocket



todo:
byt frn jwt xxxx
log in log out smidigare
inte bugga om man byter namn
renskriva
lägga till alla fetches i en fil?
logga in och logga ut sida klar - göra så man kommer till den först och inte kan röra annat innan
lägga till fält att uppdatera sin profil
fixa att lägga till bild
fixa att inloggad person är den som skriver meddelandet
fixa att skriva meddelande från det stället


18.00 promme
19.00 duscha
käka
20.00 film
{

    private final SecurityContextHolderStrategy securityContextHolderStrategy = SecurityContextHolder.getContextHolderStrategy();
    private final AuthenticationManager authenticationManager;
    private final UserRepository userRepository;
    private final AuthService authService;
    private final SecurityContextRepository securityContextRepository = new HttpSessionSecurityContextRepository();

    public LoginController(UserRepository userRepository, AuthService authService, AuthenticationManager authenticationManager) {
        this.userRepository = userRepository;
        this.authService = authService;
        this.authenticationManager = authenticationManager;
    }

    @PostMapping("/logins")
    public ResponseEntity<LoginResponse> login(@RequestBody LoginRequest loginRequest, HttpServletRequest request, HttpServletResponse response) {
        System.out.println("Received login request for username: " + loginRequest.username()); // Debug log

        try {
            UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(loginRequest.username(), loginRequest.password());
            Authentication authentication = authenticationManager.authenticate(token);

            SecurityContext context = securityContextHolderStrategy.createEmptyContext();
            context.setAuthentication(authentication);
            securityContextHolderStrategy.setContext(context);
            securityContextRepository.saveContext(context, request, response);

            Authentication authenticationResponse = SecurityContextHolder.getContext().getAuthentication();
            if (authenticationResponse != null && authenticationResponse.isAuthenticated()) {
                String username = authenticationResponse.getName();
                return ResponseEntity.ok(new LoginResponse(username));
            } else {
                return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(null);
            }
        } catch (AuthenticationException e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(null);
        }
    }



    public static class LoginResponse {
        private String username;

        public LoginResponse(String username) {
            this.username = username;
        }

        public String getUsername() {
            return username;
        }

        public void setUsername(String username) {
            this.username = username;
        }
    }

    public static record LoginRequest(String username, String password) {
    }
}